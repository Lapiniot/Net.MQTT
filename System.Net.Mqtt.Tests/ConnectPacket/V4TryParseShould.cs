using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace System.Net.Mqtt.Tests.ConnectPacket;

[TestClass]
public class V4TryParseShould
{
    private readonly ReadOnlySequence<byte> fragmentedSample;
    private readonly ReadOnlySequence<byte> invalidSizeFragmentedSample;

    private readonly ReadOnlySequence<byte> invalidSizeSample = new(new ReadOnlyMemory<byte>(new byte[]
    {
        0x10, 0x50, 0x00, 0x04, 0x4d, 0x51, 0x54, 0x54, 0x04, 0xc6, 0x00, 0x78, 0x00, 0x0c, 0x54, 0x65,
        0x73, 0x74, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x64, 0x00, 0x0d, 0x54, 0x65, 0x73, 0x74,
        0x57, 0x69, 0x6c, 0x6c, 0x54, 0x6f, 0x70, 0x69, 0x63, 0x00, 0x0f, 0x54, 0x65, 0x73, 0x74, 0x57,
        0x69, 0x6c, 0x6c, 0x4d, 0x65, 0x73, 0x73, 0x61
    }));

    private readonly ReadOnlySequence<byte> invalidTypeFragmentedSample;

    private readonly ReadOnlySequence<byte> invalidTypeSample = new(new ReadOnlyMemory<byte>(new byte[]
    {
        0x13, 0x50, 0x00, 0x04, 0x4d, 0x51, 0x54, 0x54, 0x04, 0xc6, 0x00, 0x78, 0x00, 0x0c, 0x54, 0x65,
        0x73, 0x74, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x64, 0x00, 0x0d, 0x54, 0x65, 0x73, 0x74,
        0x57, 0x69, 0x6c, 0x6c, 0x54, 0x6f, 0x70, 0x69, 0x63, 0x00, 0x0f, 0x54, 0x65, 0x73, 0x74, 0x57,
        0x69, 0x6c, 0x6c, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x00, 0x08, 0x54, 0x65, 0x73, 0x74,
        0x55, 0x73, 0x65, 0x72, 0x00, 0x0c, 0x54, 0x65, 0x73, 0x74, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f,
        0x72, 0x64
    }));

    private readonly ReadOnlySequence<byte> noClientIdSample = new(new ReadOnlyMemory<byte>(new byte[]
    {
        0x10, 0x44, 0x00, 0x04, 0x4d, 0x51, 0x54, 0x54, 0x04, 0xf6, 0x00, 0x78, 0x00, 0x00, 0x00, 0x0d,
        0x54, 0x65, 0x73, 0x74, 0x57, 0x69, 0x6c, 0x6c, 0x54, 0x6f, 0x70, 0x69, 0x63, 0x00, 0x0f, 0x54,
        0x65, 0x73, 0x74, 0x57, 0x69, 0x6c, 0x6c, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x00, 0x08,
        0x54, 0x65, 0x73, 0x74, 0x55, 0x73, 0x65, 0x72, 0x00, 0x0c, 0x54, 0x65, 0x73, 0x74, 0x50, 0x61,
        0x73, 0x73, 0x77, 0x6f, 0x72, 0x64
    }));

    private readonly ReadOnlySequence<byte> noPasswordSample = new(new ReadOnlyMemory<byte>(new byte[]
    {
        0x10, 0x16, 0x00, 0x04, 0x4d, 0x51, 0x54, 0x54, 0x04, 0xb2, 0x00, 0x78, 0x00, 0x00, 0x00, 0x08,
        0x54, 0x65, 0x73, 0x74, 0x55, 0x73, 0x65, 0x72
    }));

    private readonly ReadOnlySequence<byte> noUserNameSample = new(new ReadOnlyMemory<byte>(new byte[]
    {
        0x10, 0x0c, 0x00, 0x04, 0x4d, 0x51, 0x54, 0x54, 0x04, 0x32, 0x00, 0x78, 0x00, 0x00
    }));

    private readonly ReadOnlySequence<byte> noWillMessageSample = new(new ReadOnlyMemory<byte>(new byte[]
    {
        0x10, 0x30, 0x00, 0x04, 0x4d, 0x51, 0x54, 0x54, 0x04, 0xf2, 0x00, 0x78, 0x00, 0x0c, 0x54, 0x65,
        0x73, 0x74, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x64, 0x00, 0x08, 0x54, 0x65, 0x73, 0x74,
        0x55, 0x73, 0x65, 0x72, 0x00, 0x0c, 0x54, 0x65, 0x73, 0x74, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f,
        0x72, 0x64
    }));

    private readonly ReadOnlySequence<byte> sample = new(new ReadOnlyMemory<byte>(new byte[]
    {
        0x10, 0x50, 0x00, 0x04, 0x4d, 0x51, 0x54, 0x54, 0x04, 0xf6, 0x00, 0x78, 0x00, 0x0c, 0x54, 0x65,
        0x73, 0x74, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x64, 0x00, 0x0d, 0x54, 0x65, 0x73, 0x74,
        0x57, 0x69, 0x6c, 0x6c, 0x54, 0x6f, 0x70, 0x69, 0x63, 0x00, 0x0f, 0x54, 0x65, 0x73, 0x74, 0x57,
        0x69, 0x6c, 0x6c, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x00, 0x08, 0x54, 0x65, 0x73, 0x74,
        0x55, 0x73, 0x65, 0x72, 0x00, 0x0c, 0x54, 0x65, 0x73, 0x74, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f,
        0x72, 0x64
    }));

    public V4TryParseShould()
    {
        var segment1 = new Segment<byte>(new byte[]
        {
            0x10, 0x50, 0x00, 0x04, 0x4d, 0x51, 0x54, 0x54, 0x04, 0xf6, 0x00, 0x78, 0x00, 0x0c, 0x54, 0x65,
            0x73, 0x74, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x64, 0x00, 0x0d, 0x54, 0x65, 0x73, 0x74
        });

        var segment2 = segment1
            .Append(new byte[]
            {
                0x57, 0x69, 0x6c, 0x6c, 0x54, 0x6f, 0x70, 0x69, 0x63, 0x00, 0x0f, 0x54, 0x65, 0x73, 0x74, 0x57,
                0x69, 0x6c, 0x6c, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x00, 0x08, 0x54, 0x65, 0x73, 0x74
            })
            .Append(new byte[]
            {
                0x55, 0x73, 0x65, 0x72, 0x00, 0x0c, 0x54, 0x65, 0x73, 0x74, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f,
                0x72, 0x64
            });

        fragmentedSample = new(segment1, 0, segment2, 18);

        segment1 = new(new byte[]
        {
            0x13, 0x50, 0x00, 0x04, 0x4d, 0x51, 0x54, 0x54, 0x04, 0xf6, 0x00, 0x78, 0x00, 0x0c, 0x54, 0x65,
            0x73, 0x74, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x64, 0x00, 0x0d, 0x54, 0x65, 0x73, 0x74
        });

        segment2 = segment1
            .Append(new byte[]
            {
                0x57, 0x69, 0x6c, 0x6c, 0x54, 0x6f, 0x70, 0x69, 0x63, 0x00, 0x0f, 0x54, 0x65, 0x73, 0x74, 0x57,
                0x69, 0x6c, 0x6c, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x00, 0x08, 0x54, 0x65, 0x73, 0x74
            })
            .Append(new byte[]
            {
                0x55, 0x73, 0x65, 0x72, 0x00, 0x0c, 0x54, 0x65, 0x73, 0x74, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f,
                0x72, 0x64
            });

        invalidTypeFragmentedSample = new(segment1, 0, segment2, 18);

        segment1 = new(new byte[]
        {
            0x13, 0x50, 0x00, 0x04, 0x4d, 0x51, 0x54, 0x54, 0x04, 0xf6, 0x00, 0x78, 0x00, 0x0c, 0x54, 0x65,
            0x73, 0x74, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x64, 0x00, 0x0d, 0x54, 0x65, 0x73, 0x74
        });

        segment2 = segment1
            .Append(new byte[]
            {
                0x57, 0x69, 0x6c, 0x6c, 0x54, 0x6f, 0x70, 0x69, 0x63, 0x00, 0x0f, 0x54, 0x65, 0x73, 0x74, 0x57,
                0x69, 0x6c, 0x6c, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x00, 0x08, 0x54, 0x65, 0x73, 0x74
            })
            .Append(new byte[]
            {
                0x55, 0x73, 0x65, 0x72, 0x00, 0x0c, 0x54, 0x65, 0x73, 0x74, 0x50, 0x61, 0x73
            });

        invalidSizeFragmentedSample = new(segment1, 0, segment2, 13);
    }

    [TestMethod]
    public void ReturnTrueAndValidPacketGivenSample()
    {
        var actual = Packets.ConnectPacket.TryRead(in sample, out var packet, out _);

        Assert.IsTrue(actual);
        Assert.IsNotNull(packet);
        Assert.IsTrue(packet.ProtocolName.Span.SequenceEqual("MQTT"));
        Assert.AreEqual(0x04, packet.ProtocolLevel);
        Assert.AreEqual(2, packet.WillQoS);
        Assert.IsTrue(packet.WillRetain);
        Assert.IsTrue(packet.CleanSession);
        Assert.AreEqual(120, packet.KeepAlive);
        Assert.IsTrue(packet.ClientId.Span.SequenceEqual("TestClientId"));
        Assert.IsTrue(packet.WillTopic.Span.SequenceEqual("TestWillTopic"));
        Assert.IsTrue(packet.WillMessage.Span.SequenceEqual("TestWillMessage"));
        Assert.IsTrue(packet.UserName.Span.SequenceEqual("TestUser"));
        Assert.IsTrue(packet.Password.Span.SequenceEqual("TestPassword"));
    }

    [TestMethod]
    public void ReturnTrueAndValidPacketGivenFragmentedSample()
    {
        var actual = Packets.ConnectPacket.TryRead(in fragmentedSample, out var packet, out _);

        Assert.IsTrue(actual);
        Assert.IsNotNull(packet);
        Assert.IsTrue(packet.ProtocolName.Span.SequenceEqual("MQTT"));
        Assert.AreEqual(0x04, packet.ProtocolLevel);
        Assert.AreEqual(2, packet.WillQoS);
        Assert.IsTrue(packet.WillRetain);
        Assert.IsTrue(packet.CleanSession);
        Assert.AreEqual(120, packet.KeepAlive);
        Assert.IsTrue(packet.ClientId.Span.SequenceEqual("TestClientId"));
        Assert.IsTrue(packet.WillTopic.Span.SequenceEqual("TestWillTopic"));
        Assert.IsTrue(packet.WillMessage.Span.SequenceEqual("TestWillMessage"));
        Assert.IsTrue(packet.UserName.Span.SequenceEqual("TestUser"));
        Assert.IsTrue(packet.Password.Span.SequenceEqual("TestPassword"));
    }

    [TestMethod]
    public void ReturnTrueAndPacketNotNullWillTopicNullGivenSampleWithNoWillMessage()
    {
        var actual = Packets.ConnectPacket.TryRead(in noWillMessageSample, out var packet, out _);

        Assert.IsTrue(actual);
        Assert.IsNotNull(packet);
        Assert.IsTrue(packet.WillTopic.IsEmpty);
        Assert.AreEqual(0, packet.WillMessage.Length);
    }

    [TestMethod]
    public void ReturnTrueAndPacketNotNullClientIdNullGivenSampleWithNoClientId()
    {
        var actual = Packets.ConnectPacket.TryRead(in noClientIdSample, out var packet, out _);

        Assert.IsTrue(actual);
        Assert.IsNotNull(packet);
        Assert.IsTrue(packet.ClientId.IsEmpty);
    }

    [TestMethod]
    public void ReturnTrueAndPacketNotNullUserNameNullGivenSampleWithNoUserName()
    {
        var actual = Packets.ConnectPacket.TryRead(in noUserNameSample, out var packet, out _);

        Assert.IsTrue(actual);
        Assert.IsNotNull(packet);
        Assert.IsTrue(packet.UserName.IsEmpty);
    }

    [TestMethod]
    public void ReturnTrueAndPacketNotNullPasswordNullGivenSampleWithNoPassword()
    {
        var actual = Packets.ConnectPacket.TryRead(in noPasswordSample, out var packet, out _);

        Assert.IsTrue(actual);
        Assert.IsNotNull(packet);
        Assert.IsTrue(packet.Password.IsEmpty);
    }

    [TestMethod]
    public void ReturnFalseAndPacketNullGivenInvalidTypeSample()
    {
        var actual = Packets.ConnectPacket.TryRead(in invalidTypeSample, out var packet, out _);

        Assert.IsFalse(actual);
        Assert.IsNull(packet);
    }

    [TestMethod]
    public void ReturnFalseAndPacketNullGivenInvalidTypeFragmentedSample()
    {
        var actual = Packets.ConnectPacket.TryRead(in invalidTypeFragmentedSample, out var packet, out _);

        Assert.IsFalse(actual);
        Assert.IsNull(packet);
    }

    [TestMethod]
    public void ReturnFalseAndPacketNullGivenInvalidSizeSample()
    {
        var actual = Packets.ConnectPacket.TryRead(in invalidSizeSample, out var packet, out _);

        Assert.IsFalse(actual);
        Assert.IsNull(packet);
    }

    [TestMethod]
    public void ReturnFalseAndPacketNullGivenInvalidSizeFragmentedSample()
    {
        var actual = Packets.ConnectPacket.TryRead(in invalidSizeFragmentedSample, out var packet, out _);

        Assert.IsFalse(actual);
        Assert.IsNull(packet);
    }
}