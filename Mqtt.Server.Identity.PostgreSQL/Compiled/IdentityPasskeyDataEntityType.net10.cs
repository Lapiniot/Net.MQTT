// <auto-generated />
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Microsoft.AspNetCore.Identity;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using Npgsql.EntityFrameworkCore.PostgreSQL.Storage.Internal.Mapping;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Mqtt.Server.Identity.PostgreSQL.Compiled
{
    [EntityFrameworkInternal]
    public partial class IdentityPasskeyDataEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.AspNetCore.Identity.IdentityPasskeyData",
                typeof(IdentityPasskeyData),
                baseEntityType,
                propertyCount: 11,
                foreignKeyCount: 1,
                keyCount: 1);

            var identityUserPasskeyCredentialId = runtimeEntityType.AddProperty(
                "IdentityUserPasskeyCredentialId",
                typeof(byte[]),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            identityUserPasskeyCredentialId.SetAccessors(
                byte[] (IInternalEntry entry) => (entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<byte[]>(0) : (entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<byte[]>(0) == null ? entry.ReadTemporaryValue<byte[]>(0) : entry.ReadShadowValue<byte[]>(0))),
                byte[] (IInternalEntry entry) => entry.ReadShadowValue<byte[]>(0),
                byte[] (IInternalEntry entry) => entry.ReadOriginalValue<byte[]>(identityUserPasskeyCredentialId, 0),
                byte[] (IInternalEntry entry) => ((InternalEntityEntry)(entry)).ReadRelationshipSnapshotValue<byte[]>(identityUserPasskeyCredentialId, 0));
            identityUserPasskeyCredentialId.SetPropertyIndexes(
                index: 0,
                originalValueIndex: 0,
                shadowIndex: 0,
                relationshipIndex: 0,
                storeGenerationIndex: 0);
            identityUserPasskeyCredentialId.TypeMapping = NpgsqlByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => ((object)v).GetHashCode(),
                    byte[] (byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                    byte[] (byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                    byte[] (byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 1024));
            identityUserPasskeyCredentialId.SetCurrentValueComparer(new StructuralEntryCurrentValueComparer(identityUserPasskeyCredentialId));
            identityUserPasskeyCredentialId.AddAnnotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None);

            var attestationObject = runtimeEntityType.AddProperty(
                "AttestationObject",
                typeof(byte[]),
                propertyInfo: typeof(IdentityPasskeyData).GetProperty("AttestationObject", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityPasskeyData).GetField("<AttestationObject>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            attestationObject.SetGetter(
                byte[] (IdentityPasskeyData instance) => IdentityPasskeyDataUnsafeAccessors.AttestationObject(instance),
                bool (IdentityPasskeyData instance) => IdentityPasskeyDataUnsafeAccessors.AttestationObject(instance) == null);
            attestationObject.SetSetter(
                IdentityPasskeyData (IdentityPasskeyData instance, byte[] value) =>
                {
                    IdentityPasskeyDataUnsafeAccessors.AttestationObject(instance) = value;
                    return instance;
                });
            attestationObject.SetMaterializationSetter(
                IdentityPasskeyData (IdentityPasskeyData instance, byte[] value) =>
                {
                    IdentityPasskeyDataUnsafeAccessors.AttestationObject(instance) = value;
                    return instance;
                });
            attestationObject.SetAccessors(
                byte[] (IInternalEntry entry) => IdentityPasskeyDataUnsafeAccessors.AttestationObject(((IdentityPasskeyData)(entry.Entity))),
                byte[] (IInternalEntry entry) => IdentityPasskeyDataUnsafeAccessors.AttestationObject(((IdentityPasskeyData)(entry.Entity))),
                byte[] (IInternalEntry entry) => entry.ReadOriginalValue<byte[]>(attestationObject, 1),
                byte[] (IInternalEntry entry) => entry.GetCurrentValue<byte[]>(attestationObject));
            attestationObject.SetPropertyIndexes(
                index: 1,
                originalValueIndex: 1,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            attestationObject.TypeMapping = NpgsqlByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => ((object)v).GetHashCode(),
                    byte[] (byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                    byte[] (byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                    byte[] (byte[] source) => source.ToArray()));
            attestationObject.AddAnnotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None);

            var clientDataJson = runtimeEntityType.AddProperty(
                "ClientDataJson",
                typeof(byte[]),
                propertyInfo: typeof(IdentityPasskeyData).GetProperty("ClientDataJson", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityPasskeyData).GetField("<ClientDataJson>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            clientDataJson.SetGetter(
                byte[] (IdentityPasskeyData instance) => IdentityPasskeyDataUnsafeAccessors.ClientDataJson(instance),
                bool (IdentityPasskeyData instance) => IdentityPasskeyDataUnsafeAccessors.ClientDataJson(instance) == null);
            clientDataJson.SetSetter(
                IdentityPasskeyData (IdentityPasskeyData instance, byte[] value) =>
                {
                    IdentityPasskeyDataUnsafeAccessors.ClientDataJson(instance) = value;
                    return instance;
                });
            clientDataJson.SetMaterializationSetter(
                IdentityPasskeyData (IdentityPasskeyData instance, byte[] value) =>
                {
                    IdentityPasskeyDataUnsafeAccessors.ClientDataJson(instance) = value;
                    return instance;
                });
            clientDataJson.SetAccessors(
                byte[] (IInternalEntry entry) => IdentityPasskeyDataUnsafeAccessors.ClientDataJson(((IdentityPasskeyData)(entry.Entity))),
                byte[] (IInternalEntry entry) => IdentityPasskeyDataUnsafeAccessors.ClientDataJson(((IdentityPasskeyData)(entry.Entity))),
                byte[] (IInternalEntry entry) => entry.ReadOriginalValue<byte[]>(clientDataJson, 2),
                byte[] (IInternalEntry entry) => entry.GetCurrentValue<byte[]>(clientDataJson));
            clientDataJson.SetPropertyIndexes(
                index: 2,
                originalValueIndex: 2,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            clientDataJson.TypeMapping = NpgsqlByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => ((object)v).GetHashCode(),
                    byte[] (byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                    byte[] (byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                    byte[] (byte[] source) => source.ToArray()));
            clientDataJson.AddAnnotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None);

            var createdAt = runtimeEntityType.AddProperty(
                "CreatedAt",
                typeof(DateTimeOffset),
                propertyInfo: typeof(IdentityPasskeyData).GetProperty("CreatedAt", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityPasskeyData).GetField("<CreatedAt>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new DateTimeOffset(new DateTime(1, 1, 1, 0, 0, 0, 0, DateTimeKind.Unspecified), new TimeSpan(0, 0, 0, 0, 0)));
            createdAt.SetGetter(
                DateTimeOffset (IdentityPasskeyData instance) => IdentityPasskeyDataUnsafeAccessors.CreatedAt(instance),
                bool (IdentityPasskeyData instance) => IdentityPasskeyDataUnsafeAccessors.CreatedAt(instance).EqualsExact(default(DateTimeOffset)));
            createdAt.SetSetter(
                IdentityPasskeyData (IdentityPasskeyData instance, DateTimeOffset value) =>
                {
                    IdentityPasskeyDataUnsafeAccessors.CreatedAt(instance) = value;
                    return instance;
                });
            createdAt.SetMaterializationSetter(
                IdentityPasskeyData (IdentityPasskeyData instance, DateTimeOffset value) =>
                {
                    IdentityPasskeyDataUnsafeAccessors.CreatedAt(instance) = value;
                    return instance;
                });
            createdAt.SetAccessors(
                DateTimeOffset (IInternalEntry entry) => IdentityPasskeyDataUnsafeAccessors.CreatedAt(((IdentityPasskeyData)(entry.Entity))),
                DateTimeOffset (IInternalEntry entry) => IdentityPasskeyDataUnsafeAccessors.CreatedAt(((IdentityPasskeyData)(entry.Entity))),
                DateTimeOffset (IInternalEntry entry) => entry.ReadOriginalValue<DateTimeOffset>(createdAt, 3),
                DateTimeOffset (IInternalEntry entry) => entry.GetCurrentValue<DateTimeOffset>(createdAt));
            createdAt.SetPropertyIndexes(
                index: 3,
                originalValueIndex: 3,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            createdAt.TypeMapping = NpgsqlTimestampTzTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTimeOffset>(
                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
                    DateTimeOffset (DateTimeOffset v) => v),
                keyComparer: new ValueComparer<DateTimeOffset>(
                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
                    DateTimeOffset (DateTimeOffset v) => v),
                providerValueComparer: new ValueComparer<DateTimeOffset>(
                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
                    DateTimeOffset (DateTimeOffset v) => v),
                clrType: typeof(DateTimeOffset),
                jsonValueReaderWriter: new NpgsqlTimestampTzTypeMapping.NpgsqlJsonTimestampTzDateTimeOffsetReaderWriter());
            createdAt.AddAnnotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None);

            var isBackedUp = runtimeEntityType.AddProperty(
                "IsBackedUp",
                typeof(bool),
                propertyInfo: typeof(IdentityPasskeyData).GetProperty("IsBackedUp", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityPasskeyData).GetField("<IsBackedUp>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: false);
            isBackedUp.SetGetter(
                bool (IdentityPasskeyData instance) => IdentityPasskeyDataUnsafeAccessors.IsBackedUp(instance),
                bool (IdentityPasskeyData instance) => IdentityPasskeyDataUnsafeAccessors.IsBackedUp(instance) == false);
            isBackedUp.SetSetter(
                IdentityPasskeyData (IdentityPasskeyData instance, bool value) =>
                {
                    IdentityPasskeyDataUnsafeAccessors.IsBackedUp(instance) = value;
                    return instance;
                });
            isBackedUp.SetMaterializationSetter(
                IdentityPasskeyData (IdentityPasskeyData instance, bool value) =>
                {
                    IdentityPasskeyDataUnsafeAccessors.IsBackedUp(instance) = value;
                    return instance;
                });
            isBackedUp.SetAccessors(
                bool (IInternalEntry entry) => IdentityPasskeyDataUnsafeAccessors.IsBackedUp(((IdentityPasskeyData)(entry.Entity))),
                bool (IInternalEntry entry) => IdentityPasskeyDataUnsafeAccessors.IsBackedUp(((IdentityPasskeyData)(entry.Entity))),
                bool (IInternalEntry entry) => entry.ReadOriginalValue<bool>(isBackedUp, 4),
                bool (IInternalEntry entry) => entry.GetCurrentValue<bool>(isBackedUp));
            isBackedUp.SetPropertyIndexes(
                index: 4,
                originalValueIndex: 4,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            isBackedUp.TypeMapping = NpgsqlBoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v));
            isBackedUp.AddAnnotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None);

            var isBackupEligible = runtimeEntityType.AddProperty(
                "IsBackupEligible",
                typeof(bool),
                propertyInfo: typeof(IdentityPasskeyData).GetProperty("IsBackupEligible", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityPasskeyData).GetField("<IsBackupEligible>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: false);
            isBackupEligible.SetGetter(
                bool (IdentityPasskeyData instance) => IdentityPasskeyDataUnsafeAccessors.IsBackupEligible(instance),
                bool (IdentityPasskeyData instance) => IdentityPasskeyDataUnsafeAccessors.IsBackupEligible(instance) == false);
            isBackupEligible.SetSetter(
                IdentityPasskeyData (IdentityPasskeyData instance, bool value) =>
                {
                    IdentityPasskeyDataUnsafeAccessors.IsBackupEligible(instance) = value;
                    return instance;
                });
            isBackupEligible.SetMaterializationSetter(
                IdentityPasskeyData (IdentityPasskeyData instance, bool value) =>
                {
                    IdentityPasskeyDataUnsafeAccessors.IsBackupEligible(instance) = value;
                    return instance;
                });
            isBackupEligible.SetAccessors(
                bool (IInternalEntry entry) => IdentityPasskeyDataUnsafeAccessors.IsBackupEligible(((IdentityPasskeyData)(entry.Entity))),
                bool (IInternalEntry entry) => IdentityPasskeyDataUnsafeAccessors.IsBackupEligible(((IdentityPasskeyData)(entry.Entity))),
                bool (IInternalEntry entry) => entry.ReadOriginalValue<bool>(isBackupEligible, 5),
                bool (IInternalEntry entry) => entry.GetCurrentValue<bool>(isBackupEligible));
            isBackupEligible.SetPropertyIndexes(
                index: 5,
                originalValueIndex: 5,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            isBackupEligible.TypeMapping = NpgsqlBoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v));
            isBackupEligible.AddAnnotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None);

            var isUserVerified = runtimeEntityType.AddProperty(
                "IsUserVerified",
                typeof(bool),
                propertyInfo: typeof(IdentityPasskeyData).GetProperty("IsUserVerified", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityPasskeyData).GetField("<IsUserVerified>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: false);
            isUserVerified.SetGetter(
                bool (IdentityPasskeyData instance) => IdentityPasskeyDataUnsafeAccessors.IsUserVerified(instance),
                bool (IdentityPasskeyData instance) => IdentityPasskeyDataUnsafeAccessors.IsUserVerified(instance) == false);
            isUserVerified.SetSetter(
                IdentityPasskeyData (IdentityPasskeyData instance, bool value) =>
                {
                    IdentityPasskeyDataUnsafeAccessors.IsUserVerified(instance) = value;
                    return instance;
                });
            isUserVerified.SetMaterializationSetter(
                IdentityPasskeyData (IdentityPasskeyData instance, bool value) =>
                {
                    IdentityPasskeyDataUnsafeAccessors.IsUserVerified(instance) = value;
                    return instance;
                });
            isUserVerified.SetAccessors(
                bool (IInternalEntry entry) => IdentityPasskeyDataUnsafeAccessors.IsUserVerified(((IdentityPasskeyData)(entry.Entity))),
                bool (IInternalEntry entry) => IdentityPasskeyDataUnsafeAccessors.IsUserVerified(((IdentityPasskeyData)(entry.Entity))),
                bool (IInternalEntry entry) => entry.ReadOriginalValue<bool>(isUserVerified, 6),
                bool (IInternalEntry entry) => entry.GetCurrentValue<bool>(isUserVerified));
            isUserVerified.SetPropertyIndexes(
                index: 6,
                originalValueIndex: 6,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            isUserVerified.TypeMapping = NpgsqlBoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v));
            isUserVerified.AddAnnotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None);

            var name = runtimeEntityType.AddProperty(
                "Name",
                typeof(string),
                propertyInfo: typeof(IdentityPasskeyData).GetProperty("Name", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityPasskeyData).GetField("<Name>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            name.SetGetter(
                string (IdentityPasskeyData instance) => IdentityPasskeyDataUnsafeAccessors.Name(instance),
                bool (IdentityPasskeyData instance) => IdentityPasskeyDataUnsafeAccessors.Name(instance) == null);
            name.SetSetter(
                IdentityPasskeyData (IdentityPasskeyData instance, string value) =>
                {
                    IdentityPasskeyDataUnsafeAccessors.Name(instance) = value;
                    return instance;
                });
            name.SetMaterializationSetter(
                IdentityPasskeyData (IdentityPasskeyData instance, string value) =>
                {
                    IdentityPasskeyDataUnsafeAccessors.Name(instance) = value;
                    return instance;
                });
            name.SetAccessors(
                string (IInternalEntry entry) => IdentityPasskeyDataUnsafeAccessors.Name(((IdentityPasskeyData)(entry.Entity))),
                string (IInternalEntry entry) => IdentityPasskeyDataUnsafeAccessors.Name(((IdentityPasskeyData)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(name, 7),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(name));
            name.SetPropertyIndexes(
                index: 7,
                originalValueIndex: 7,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            name.TypeMapping = StringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                keyComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    dbType: System.Data.DbType.String));
            name.AddAnnotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None);

            var publicKey = runtimeEntityType.AddProperty(
                "PublicKey",
                typeof(byte[]),
                propertyInfo: typeof(IdentityPasskeyData).GetProperty("PublicKey", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityPasskeyData).GetField("<PublicKey>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            publicKey.SetGetter(
                byte[] (IdentityPasskeyData instance) => IdentityPasskeyDataUnsafeAccessors.PublicKey(instance),
                bool (IdentityPasskeyData instance) => IdentityPasskeyDataUnsafeAccessors.PublicKey(instance) == null);
            publicKey.SetSetter(
                IdentityPasskeyData (IdentityPasskeyData instance, byte[] value) =>
                {
                    IdentityPasskeyDataUnsafeAccessors.PublicKey(instance) = value;
                    return instance;
                });
            publicKey.SetMaterializationSetter(
                IdentityPasskeyData (IdentityPasskeyData instance, byte[] value) =>
                {
                    IdentityPasskeyDataUnsafeAccessors.PublicKey(instance) = value;
                    return instance;
                });
            publicKey.SetAccessors(
                byte[] (IInternalEntry entry) => IdentityPasskeyDataUnsafeAccessors.PublicKey(((IdentityPasskeyData)(entry.Entity))),
                byte[] (IInternalEntry entry) => IdentityPasskeyDataUnsafeAccessors.PublicKey(((IdentityPasskeyData)(entry.Entity))),
                byte[] (IInternalEntry entry) => entry.ReadOriginalValue<byte[]>(publicKey, 8),
                byte[] (IInternalEntry entry) => entry.GetCurrentValue<byte[]>(publicKey));
            publicKey.SetPropertyIndexes(
                index: 8,
                originalValueIndex: 8,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            publicKey.TypeMapping = NpgsqlByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => ((object)v).GetHashCode(),
                    byte[] (byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                    byte[] (byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                    byte[] (byte[] source) => source.ToArray()));
            publicKey.AddAnnotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None);

            var signCount = runtimeEntityType.AddProperty(
                "SignCount",
                typeof(uint),
                propertyInfo: typeof(IdentityPasskeyData).GetProperty("SignCount", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityPasskeyData).GetField("<SignCount>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            signCount.SetGetter(
                uint (IdentityPasskeyData instance) => IdentityPasskeyDataUnsafeAccessors.SignCount(instance),
                bool (IdentityPasskeyData instance) => IdentityPasskeyDataUnsafeAccessors.SignCount(instance) == 0U);
            signCount.SetSetter(
                IdentityPasskeyData (IdentityPasskeyData instance, uint value) =>
                {
                    IdentityPasskeyDataUnsafeAccessors.SignCount(instance) = value;
                    return instance;
                });
            signCount.SetMaterializationSetter(
                IdentityPasskeyData (IdentityPasskeyData instance, uint value) =>
                {
                    IdentityPasskeyDataUnsafeAccessors.SignCount(instance) = value;
                    return instance;
                });
            signCount.SetAccessors(
                uint (IInternalEntry entry) => IdentityPasskeyDataUnsafeAccessors.SignCount(((IdentityPasskeyData)(entry.Entity))),
                uint (IInternalEntry entry) => IdentityPasskeyDataUnsafeAccessors.SignCount(((IdentityPasskeyData)(entry.Entity))),
                uint (IInternalEntry entry) => entry.ReadOriginalValue<uint>(signCount, 9),
                uint (IInternalEntry entry) => entry.GetCurrentValue<uint>(signCount));
            signCount.SetPropertyIndexes(
                index: 9,
                originalValueIndex: 9,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            signCount.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v),
                keyComparer: new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v),
                providerValueComparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v),
                converter: new ValueConverter<uint, long>(
                    long (uint v) => ((long)(v)),
                    uint (long v) => ((uint)(v))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<uint, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<uint, long>(
                        long (uint v) => ((long)(v)),
                        uint (long v) => ((uint)(v)))));
            signCount.SetSentinelFromProviderValue(0L);
            signCount.AddAnnotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None);

            var transports = runtimeEntityType.AddProperty(
                "Transports",
                typeof(string[]),
                propertyInfo: typeof(IdentityPasskeyData).GetProperty("Transports", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityPasskeyData).GetField("<Transports>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            transports.SetGetter(
                string[] (IdentityPasskeyData instance) => IdentityPasskeyDataUnsafeAccessors.Transports(instance),
                bool (IdentityPasskeyData instance) => IdentityPasskeyDataUnsafeAccessors.Transports(instance) == null);
            transports.SetSetter(
                IdentityPasskeyData (IdentityPasskeyData instance, string[] value) =>
                {
                    IdentityPasskeyDataUnsafeAccessors.Transports(instance) = value;
                    return instance;
                });
            transports.SetMaterializationSetter(
                IdentityPasskeyData (IdentityPasskeyData instance, string[] value) =>
                {
                    IdentityPasskeyDataUnsafeAccessors.Transports(instance) = value;
                    return instance;
                });
            transports.SetAccessors(
                string[] (IInternalEntry entry) => IdentityPasskeyDataUnsafeAccessors.Transports(((IdentityPasskeyData)(entry.Entity))),
                string[] (IInternalEntry entry) => IdentityPasskeyDataUnsafeAccessors.Transports(((IdentityPasskeyData)(entry.Entity))),
                string[] (IInternalEntry entry) => entry.ReadOriginalValue<string[]>(transports, 10),
                string[] (IInternalEntry entry) => entry.GetCurrentValue<string[]>(transports));
            transports.SetPropertyIndexes(
                index: 10,
                originalValueIndex: 10,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            transports.TypeMapping = NpgsqlJsonTypeMapping.Default.Clone(
                comparer: new ListOfReferenceTypesComparer<string[], string>(new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v)),
                keyComparer: new ListOfReferenceTypesComparer<string[], string>(new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionOfReferencesReaderWriter<string[], string>(
                    JsonStringReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<string[], string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: StringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        dbType: System.Data.DbType.String)));
            var transportsElementType = transports.SetElementType(typeof(string));
            transportsElementType.TypeMapping = transports.TypeMapping.ElementTypeMapping;
            transports.AddAnnotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { identityUserPasskeyCredentialId });
            runtimeEntityType.SetPrimaryKey(key);
            key.AddAnnotation("Relational:Name", "pk_identity_passkey_data");

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("IdentityUserPasskeyCredentialId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("CredentialId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                unique: true,
                required: true,
                requiredDependent: true,
                ownership: true);

            var data = principalEntityType.AddNavigation("Data",
                runtimeForeignKey,
                onDependent: false,
                typeof(IdentityPasskeyData),
                propertyInfo: typeof(IdentityUserPasskey<string>).GetProperty("Data", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUserPasskey<string>).GetField("<Data>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                eagerLoaded: true);

            data.SetGetter(
                IdentityPasskeyData (IdentityUserPasskey<string> instance) => IdentityUserPasskeyUnsafeAccessors<string>.Data(instance),
                bool (IdentityUserPasskey<string> instance) => IdentityUserPasskeyUnsafeAccessors<string>.Data(instance) == null);
            data.SetSetter(
                IdentityUserPasskey<string> (IdentityUserPasskey<string> instance, IdentityPasskeyData value) =>
                {
                    IdentityUserPasskeyUnsafeAccessors<string>.Data(instance) = value;
                    return instance;
                });
            data.SetMaterializationSetter(
                IdentityUserPasskey<string> (IdentityUserPasskey<string> instance, IdentityPasskeyData value) =>
                {
                    IdentityUserPasskeyUnsafeAccessors<string>.Data(instance) = value;
                    return instance;
                });
            data.SetAccessors(
                IdentityPasskeyData (IInternalEntry entry) => IdentityUserPasskeyUnsafeAccessors<string>.Data(((IdentityUserPasskey<string>)(entry.Entity))),
                IdentityPasskeyData (IInternalEntry entry) => IdentityUserPasskeyUnsafeAccessors<string>.Data(((IdentityUserPasskey<string>)(entry.Entity))),
                null,
                IdentityPasskeyData (IInternalEntry entry) => entry.GetCurrentValue<IdentityPasskeyData>(data));
            data.SetPropertyIndexes(
                index: 0,
                originalValueIndex: -1,
                shadowIndex: -1,
                relationshipIndex: 2,
                storeGenerationIndex: -1);
            runtimeForeignKey.AddAnnotation("Relational:Name", "fk_identity_passkey_data_asp_net_user_passkeys_identity_user_pass");
            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            var identityUserPasskeyCredentialId = runtimeEntityType.FindProperty("IdentityUserPasskeyCredentialId");
            var attestationObject = runtimeEntityType.FindProperty("AttestationObject");
            var clientDataJson = runtimeEntityType.FindProperty("ClientDataJson");
            var createdAt = runtimeEntityType.FindProperty("CreatedAt");
            var isBackedUp = runtimeEntityType.FindProperty("IsBackedUp");
            var isBackupEligible = runtimeEntityType.FindProperty("IsBackupEligible");
            var isUserVerified = runtimeEntityType.FindProperty("IsUserVerified");
            var name = runtimeEntityType.FindProperty("Name");
            var publicKey = runtimeEntityType.FindProperty("PublicKey");
            var signCount = runtimeEntityType.FindProperty("SignCount");
            var transports = runtimeEntityType.FindProperty("Transports");
            var key = runtimeEntityType.FindKey(new[] { identityUserPasskeyCredentialId });
            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNullableFactory<byte[], int>(key));
            key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<byte[]>(key));
            runtimeEntityType.SetOriginalValuesFactory(
                ISnapshot (IInternalEntry source) =>
                {
                    var structuralType = ((IdentityPasskeyData)(source.Entity));
                    return ((ISnapshot)(new Snapshot<byte[], byte[], byte[], DateTimeOffset, bool, bool, bool, string, byte[], uint, string[]>((source.GetCurrentValue<byte[]>(identityUserPasskeyCredentialId) == null ? null : ((ValueComparer<byte[]>)(((IProperty)identityUserPasskeyCredentialId).GetValueComparer())).Snapshot(source.GetCurrentValue<byte[]>(identityUserPasskeyCredentialId))), (source.GetCurrentValue<byte[]>(attestationObject) == null ? null : ((ValueComparer<byte[]>)(((IProperty)attestationObject).GetValueComparer())).Snapshot(source.GetCurrentValue<byte[]>(attestationObject))), (source.GetCurrentValue<byte[]>(clientDataJson) == null ? null : ((ValueComparer<byte[]>)(((IProperty)clientDataJson).GetValueComparer())).Snapshot(source.GetCurrentValue<byte[]>(clientDataJson))), ((ValueComparer<DateTimeOffset>)(((IProperty)createdAt).GetValueComparer())).Snapshot(source.GetCurrentValue<DateTimeOffset>(createdAt)), ((ValueComparer<bool>)(((IProperty)isBackedUp).GetValueComparer())).Snapshot(source.GetCurrentValue<bool>(isBackedUp)), ((ValueComparer<bool>)(((IProperty)isBackupEligible).GetValueComparer())).Snapshot(source.GetCurrentValue<bool>(isBackupEligible)), ((ValueComparer<bool>)(((IProperty)isUserVerified).GetValueComparer())).Snapshot(source.GetCurrentValue<bool>(isUserVerified)), (source.GetCurrentValue<string>(name) == null ? null : ((ValueComparer<string>)(((IProperty)name).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(name))), (source.GetCurrentValue<byte[]>(publicKey) == null ? null : ((ValueComparer<byte[]>)(((IProperty)publicKey).GetValueComparer())).Snapshot(source.GetCurrentValue<byte[]>(publicKey))), ((ValueComparer<uint>)(((IProperty)signCount).GetValueComparer())).Snapshot(source.GetCurrentValue<uint>(signCount)), (((object)(source.GetCurrentValue<string[]>(transports))) == null ? null : ((string[])(((ValueComparer<object>)(((IProperty)transports).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<string[]>(transports))))))))));
                });
            runtimeEntityType.SetStoreGeneratedValuesFactory(
                ISnapshot () => ((ISnapshot)(new Snapshot<byte[]>((default(byte[]) == null ? null : ((ValueComparer<byte[]>)(((IProperty)identityUserPasskeyCredentialId).GetValueComparer())).Snapshot(default(byte[])))))));
            runtimeEntityType.SetTemporaryValuesFactory(
                ISnapshot (IInternalEntry source) => ((ISnapshot)(new Snapshot<byte[]>(default(byte[])))));
            runtimeEntityType.SetShadowValuesFactory(
                ISnapshot (IDictionary<string, object> source) => ((ISnapshot)(new Snapshot<byte[]>((source.ContainsKey("IdentityUserPasskeyCredentialId") ? ((byte[])(source["IdentityUserPasskeyCredentialId"])) : null)))));
            runtimeEntityType.SetEmptyShadowValuesFactory(
                ISnapshot () => ((ISnapshot)(new Snapshot<byte[]>(default(byte[])))));
            runtimeEntityType.SetRelationshipSnapshotFactory(
                ISnapshot (IInternalEntry source) =>
                {
                    var structuralType = ((IdentityPasskeyData)(source.Entity));
                    return ((ISnapshot)(new Snapshot<byte[]>((source.GetCurrentValue<byte[]>(identityUserPasskeyCredentialId) == null ? null : ((ValueComparer<byte[]>)(((IProperty)identityUserPasskeyCredentialId).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<byte[]>(identityUserPasskeyCredentialId))))));
                });
            runtimeEntityType.SetCounts(new PropertyCounts(
                propertyCount: 11,
                navigationCount: 0,
                complexPropertyCount: 0,
                complexCollectionCount: 0,
                originalValueCount: 11,
                shadowCount: 1,
                relationshipCount: 1,
                storeGeneratedCount: 1));
            runtimeEntityType.AddAnnotation("Relational:ContainerColumnName", "data");
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "asp_net_user_passkeys");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}